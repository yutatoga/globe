<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <title>globe</title>
  <style>
  body {
    margin: 0;
    overflow: hidden;
  }

  </style>
</head>
<body>
  <script src="js/three.js"></script>
  <script src="js/dat.gui.min.js"></script>
  <script>

  var scene, camera, renderer;
  var curve, materialCurve, curveObject;
  var planeMesh0, planeMesh1, planeMesh2, planeMesh3;
  var lineMaterial, lineGeometryBetweenV2V3, lineGeometryBetweenV2V3;


  var Settings = function(){
    // The starting point
    this.v0X = -1;
    this.v0Y = +1;
    // The first control point.
    this.v1X = -0.9;
    this.v1Y = -0.3;
    // The second control point
    this.v2X = 0.7;
    this.v2Y = 0.2;
    // The ending point
    this.v3X = +1;
    this.v3Y = -1;
  };

  init();
  animate();

  function init(){
    // gui
    var settings = new Settings();
    var gui = new dat.GUI();
    gui.add(settings, 'v0X', -1, 1).onChange(updateCurve);
    gui.add(settings, 'v0Y', -1, 1).onChange(updateCurve);

    gui.add(settings, 'v1X', -1, 1).onChange(updateCurve);
    gui.add(settings, 'v1Y', -1, 1).onChange(updateCurve);

    gui.add(settings, 'v2X', -1, 1).onChange(updateCurve);
    gui.add(settings, 'v2Y', -1, 1).onChange(updateCurve);

    gui.add(settings, 'v3X', -1, 1).onChange(updateCurve);
    gui.add(settings, 'v3Y', -1, 1).onChange(updateCurve);

    function updateCurve(){
      scene.remove(curveObject);
      // avoid memory leak
      curveObject.material.dispose();
      curveObject.geometry.dispose();

      // update curve
      curve.v0.set(settings.v0X, settings.v0Y);
      curve.v1.set(settings.v1X, settings.v1Y);
      curve.v2.set(settings.v2X, settings.v2Y);
      curve.v3.set(settings.v3X, settings.v3Y);

      var points = curve.getPoints( 50 );
      var geometryCurve = new THREE.BufferGeometry().setFromPoints( points );


      curveObject = new THREE.Line( geometryCurve, materialCurve );
      scene.add(curveObject);

      // update planes
      planeMesh0.position.set(settings.v0X, settings.v0Y, 0);
      scene.add(planeMesh0);

      planeMesh1.position.set(settings.v1X, settings.v1Y, 0);
      scene.add(planeMesh1);

      planeMesh2.position.set(settings.v2X, settings.v2Y, 0);
      scene.add(planeMesh2);

      planeMesh3.position.set(settings.v3X, settings.v3Y, 0);
      scene.add(planeMesh3);

      // update lines
      lineGeometryBetweenV0V1.vertices[0] = new THREE.Vector3(settings.v0X, settings.v0Y, 0);
      lineGeometryBetweenV0V1.vertices[1] = new THREE.Vector3(settings.v1X, settings.v1Y, 0);
      lineGeometryBetweenV0V1.verticesNeedUpdate = true;

      lineGeometryBetweenV2V3.vertices[0] = new THREE.Vector3(settings.v2X, settings.v2Y, 0);
      lineGeometryBetweenV2V3.vertices[1] = new THREE.Vector3(settings.v3X, settings.v3Y, 0);
      lineGeometryBetweenV2V3.verticesNeedUpdate = true;
    };

    // scene
    scene = new THREE.Scene();

    // camera
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.z = 2;

    // renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // plane for the ruler
    var geometry = new THREE.PlaneGeometry( 2, 2 );
    var material = new THREE.MeshBasicMaterial( {
      color: 0xffff00, // yellow
      side: THREE.DoubleSide,
      wireframe: true
    } );
    var plane = new THREE.Mesh( geometry, material );
    scene.add( plane );

    // curve
    curve = new THREE.CubicBezierCurve(
      new THREE.Vector2( settings.v0X, settings.v0Y ),   // The starting point
    	new THREE.Vector2( settings.v1X, settings.v1Y ),  // The first control point.
    	new THREE.Vector2( settings.v2X, settings.v2Y ),    // The second control point
    	new THREE.Vector2( settings.v3X, settings.v3Y ),   // The ending point
    );
    var points = curve.getPoints( 50 );
    var geometryCurve = new THREE.BufferGeometry().setFromPoints( points );
    materialCurve = new THREE.LineBasicMaterial( { color : 0xff0000 } );
    // Create the final object to add to the scene
    curveObject = new THREE.Line( geometryCurve, materialCurve );
    scene.add( curveObject );

    // planese
    var planeMaterialV0 = new THREE.MeshBasicMaterial( {color: 0x00ff00, transparent: true, opacity: 0.75} );
    var planeMaterialV1 = new THREE.MeshBasicMaterial( {color: 0x009900, transparent: true, opacity: 0.75} );
    var planeMaterialV2 = new THREE.MeshBasicMaterial( {color: 0x000099, transparent: true, opacity: 0.75} );
    var planeMaterialV3 = new THREE.MeshBasicMaterial( {color: 0x0000ff, transparent: true, opacity: 0.75} );
    var planeGeometry = new THREE.PlaneGeometry( 0.05, 0.05 );

    var planeMesh0 = new THREE.Mesh( planeGeometry, planeMaterialV0 );
    planeMesh0.position.set(settings.v0X, settings.v0Y, 0);
    scene.add(planeMesh0);

    var planeMesh1 = new THREE.Mesh( planeGeometry, planeMaterialV1 );
    planeMesh1.position.set(settings.v1X, settings.v1Y, 0);
    scene.add(planeMesh1);

    var planeMesh2 = new THREE.Mesh( planeGeometry, planeMaterialV2 );
    planeMesh2.position.set(settings.v2X, settings.v2Y, 0);
    scene.add(planeMesh2);

    var planeMesh3 = new THREE.Mesh( planeGeometry, planeMaterialV3 );
    planeMesh3.position.set(settings.v3X, settings.v3Y, 0);
    scene.add(planeMesh3);

    // line
    lineMaterial = new THREE.LineBasicMaterial( {color: 0x999999} );

    // line between v0 and v1
    lineGeometryBetweenV0V1 = new THREE.Geometry();
    lineGeometryBetweenV0V1.vertices.push(
      new THREE.Vector3(settings.v0X, settings.v0Y, 0),
      new THREE.Vector3(settings.v1X, settings.v1Y, 0)
    );
    var lineBetweenV0V1 = new THREE.Line( lineGeometryBetweenV0V1, lineMaterial );
    scene.add( lineBetweenV0V1 );

    // line between v2 and v3
    lineGeometryBetweenV2V3 = new THREE.Geometry();
    lineGeometryBetweenV2V3.vertices.push(
      new THREE.Vector3(settings.v2X, settings.v2Y, 0),
      new THREE.Vector3(settings.v3X, settings.v3Y, 0)
    );
    var lineBetweenV2V3 = new THREE.Line( lineGeometryBetweenV2V3, lineMaterial );
    scene.add(lineBetweenV2V3);
  }

  function animate() {
  	requestAnimationFrame( animate );
    // scene.rotation.y += 0.01;
  	renderer.render( scene, camera );
  }

  </script>
</body>
</html>
